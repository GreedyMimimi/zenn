---
title: 【実践】XRPLで独自トークンを発行してみよう：Trust Lineハンズオン入門
emoji: 🐱
type: tech
topics: [xrpl, blockchain, web3, javascript, token]
published: false
---

## はじめに

この記事では、XRP Ledger（XRPL）上で **独自トークンを発行する方法** を、コードを動かしながら一歩ずつ学んでいきます。

「トークン発行」と聞くと難しそうに思えるかもしれませんが、XRPLでは **Trust Line（トラストライン）** という仕組みを使って、意外とシンプルにトークンを発行・送金できます。

### この記事で学べること

- Trust Lineの概念と仕組み
- 発行者（Issuer）アカウントの設定
- トークンの発行と送金
- 発行済みトークンの確認方法
- トークン設計で気をつけるポイント

### 前提知識

- JavaScriptの基本的な読み書きができる
- Node.jsがインストールされている（v18以上推奨）
- XRPLの概要をなんとなく知っている（知らなくても大丈夫）

## Trust Lineとは？

XRPLでは、XRP以外のトークン（法定通貨トークン、独自ポイントなど）を扱うために **Trust Line** という仕組みを使います。

### 銀行口座に例えると

Trust Lineは「この発行者のトークンを受け取ってもいいよ」という **受取側の同意** のようなものです。

現実世界に例えると：
- **発行者（Issuer）**：銀行やポイント発行会社
- **Trust Line設定**：その銀行に口座を開設すること
- **トークン残高**：口座の残高

Trust Lineを設定していないアカウントには、そのトークンを送ることができません。これは、**スパムトークンの送り付け防止** にもなっています。

### 図で理解する

```
┌──────────┐    Trust Line設定     ┌──────────┐
│          │  ←────────────────   │          │
│  発行者   │                      │  受取側   │
│ (Issuer)  │  ────────────────→  │ (Holder)  │
│          │    トークン送金       │          │
└──────────┘                      └──────────┘
```

1. 受取側が「発行者Aのトークンを最大◯◯まで受け取る」とTrust Lineを設定
2. 発行者が受取側にトークンを送金
3. 受取側のTrust Line残高にトークンが記録される

## 環境準備

### プロジェクトのセットアップ

まずは作業ディレクトリを作って、必要なパッケージをインストールします。

```bash
mkdir xrpl-token-tutorial
cd xrpl-token-tutorial
npm init -y
npm install xrpl
```

### テストネットを使う

今回はすべて **Testnet（テストネット）** で行います。本番のXRPは一切使わないので安心してください。

テストネットでは、Faucetから無料でテスト用XRPを受け取れます。

## Step 1：アカウントの準備

トークン発行には、最低2つのアカウントが必要です。

- **発行者アカウント（Issuer）**：トークンを発行する側
- **受取アカウント（Holder）**：トークンを受け取る側

以下のコードで、テストネット上に2つのアカウントを作成します。

```javascript
// setup-accounts.js
const xrpl = require("xrpl");

async function main() {
  const client = new xrpl.Client("wss://s.altnet.rippletest.net:51233");
  await client.connect();
  console.log("テストネットに接続しました");

  // Faucetからテスト用アカウントを2つ取得
  console.log("発行者アカウントを作成中...");
  const issuerWallet = (await client.fundWallet()).wallet;
  console.log("発行者アドレス:", issuerWallet.classicAddress);
  console.log("発行者シード:", issuerWallet.seed);

  console.log("\n受取アカウントを作成中...");
  const holderWallet = (await client.fundWallet()).wallet;
  console.log("受取アドレス:", holderWallet.classicAddress);
  console.log("受取シード:", holderWallet.seed);

  // アカウント情報を確認
  const issuerInfo = await client.request({
    command: "account_info",
    account: issuerWallet.classicAddress,
  });
  console.log(
    "\n発行者の残高:",
    xrpl.dropsToXrp(issuerInfo.result.account_data.Balance),
    "XRP"
  );

  const holderInfo = await client.request({
    command: "account_info",
    account: holderWallet.classicAddress,
  });
  console.log(
    "受取側の残高:",
    xrpl.dropsToXrp(holderInfo.result.account_data.Balance),
    "XRP"
  );

  await client.disconnect();
}

main().catch(console.error);
```

実行してみましょう。

```bash
node setup-accounts.js
```

出力例：

```
テストネットに接続しました
発行者アカウントを作成中...
発行者アドレス: rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
発行者シード: sXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

受取アカウントを作成中...
受取アドレス: rYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
受取シード: sYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY

発行者の残高: 100 XRP
受取側の残高: 100 XRP
```

:::message
出力されたアドレスとシードは、後のステップで使います。メモしておいてください。
:::

## Step 2：発行者アカウントの設定

トークンを発行する前に、発行者アカウントに適切な設定を行います。

### DefaultRipple フラグ

発行者アカウントには **DefaultRipple** フラグを有効にすることが推奨されています。これにより、発行したトークンがアカウント間で自由に転送（Rippling）できるようになります。

```javascript
// configure-issuer.js
const xrpl = require("xrpl");

// Step 1で取得したシードに置き換えてください
const ISSUER_SEED = "sXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";

async function main() {
  const client = new xrpl.Client("wss://s.altnet.rippletest.net:51233");
  await client.connect();

  const issuerWallet = xrpl.Wallet.fromSeed(ISSUER_SEED);
  console.log("発行者アドレス:", issuerWallet.classicAddress);

  // DefaultRippleを有効にする
  const settingsTx = {
    TransactionType: "AccountSet",
    Account: issuerWallet.classicAddress,
    SetFlag: xrpl.AccountSetAsfFlags.asfDefaultRipple,
  };

  console.log("DefaultRippleを設定中...");
  const result = await client.submitAndWait(settingsTx, {
    wallet: issuerWallet,
  });

  console.log(
    "結果:",
    result.result.meta.TransactionResult
  );

  if (result.result.meta.TransactionResult === "tesSUCCESS") {
    console.log("DefaultRippleが有効になりました！");
  }

  await client.disconnect();
}

main().catch(console.error);
```

```bash
node configure-issuer.js
```

### DefaultRippleはなぜ必要？

DefaultRippleを有効にしないと、発行したトークンは **発行者を経由しないと他のアカウントに送れなく** なります。つまり、AさんがBさんにトークンを直接送ることができず、一度発行者に戻してから再度送る必要が出てきます。

一般的なトークン（ポイントやステーブルコインなど）では、ユーザー間の自由な転送を許可したいので、DefaultRippleを有効にしておくのがベストプラクティスです。

## Step 3：Trust Lineの設定

次に、受取側アカウントがTrust Lineを設定します。「このトークンを受け取る準備ができたよ」という宣言です。

```javascript
// create-trustline.js
const xrpl = require("xrpl");

// Step 1で取得したシードに置き換えてください
const HOLDER_SEED = "sYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY";
const ISSUER_ADDRESS = "rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";

// トークンの通貨コード（3文字の英大文字）
const CURRENCY_CODE = "MIM";

async function main() {
  const client = new xrpl.Client("wss://s.altnet.rippletest.net:51233");
  await client.connect();

  const holderWallet = xrpl.Wallet.fromSeed(HOLDER_SEED);
  console.log("受取アドレス:", holderWallet.classicAddress);

  // Trust Lineを設定
  const trustSetTx = {
    TransactionType: "TrustSet",
    Account: holderWallet.classicAddress,
    LimitAmount: {
      currency: CURRENCY_CODE,
      issuer: ISSUER_ADDRESS,
      value: "1000000", // 最大受取量
    },
  };

  console.log(`Trust Lineを設定中（${CURRENCY_CODE}トークン）...`);
  const result = await client.submitAndWait(trustSetTx, {
    wallet: holderWallet,
  });

  console.log(
    "結果:",
    result.result.meta.TransactionResult
  );

  if (result.result.meta.TransactionResult === "tesSUCCESS") {
    console.log("Trust Lineが設定されました！");
    console.log(`${holderWallet.classicAddress} は ${CURRENCY_CODE} を最大 1,000,000 まで受け取れます`);
  }

  await client.disconnect();
}

main().catch(console.error);
```

```bash
node create-trustline.js
```

### LimitAmountについて

`LimitAmount.value` は、そのTrust Lineで保持できるトークンの **上限値** です。この値を超えるトークンは受け取れません。

- 上限を大きく設定しても、実際にトークンが送られてくるまで残高は0です
- 上限はいつでも変更できます
- 上限を0にするとTrust Lineを削除できます（残高が0の場合）

### 通貨コードのルール

XRPLの通貨コードには2種類あります。

| 種類 | 形式 | 例 |
| --- | --- | --- |
| 標準通貨コード | 3文字の英大文字 | `USD`, `JPY`, `MIM` |
| 非標準通貨コード | 40文字の16進数 | `4D794372797074 ...`（長いトークン名に使用） |

今回は標準通貨コード `MIM` を使います。

## Step 4：トークンの発行（送金）

Trust Lineが設定できたら、いよいよトークンを発行します。XRPLでは、**発行者から受取側へのPaymentトランザクション** がトークン発行になります。

```javascript
// issue-token.js
const xrpl = require("xrpl");

// Step 1で取得したシードに置き換えてください
const ISSUER_SEED = "sXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
const HOLDER_ADDRESS = "rYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY";

const CURRENCY_CODE = "MIM";
const AMOUNT_TO_ISSUE = "10000"; // 発行量

async function main() {
  const client = new xrpl.Client("wss://s.altnet.rippletest.net:51233");
  await client.connect();

  const issuerWallet = xrpl.Wallet.fromSeed(ISSUER_SEED);
  console.log("発行者アドレス:", issuerWallet.classicAddress);

  // トークンを発行（送金）
  const paymentTx = {
    TransactionType: "Payment",
    Account: issuerWallet.classicAddress,
    Destination: HOLDER_ADDRESS,
    Amount: {
      currency: CURRENCY_CODE,
      issuer: issuerWallet.classicAddress,
      value: AMOUNT_TO_ISSUE,
    },
  };

  console.log(`${AMOUNT_TO_ISSUE} ${CURRENCY_CODE} を発行中...`);
  const result = await client.submitAndWait(paymentTx, {
    wallet: issuerWallet,
  });

  console.log(
    "結果:",
    result.result.meta.TransactionResult
  );

  if (result.result.meta.TransactionResult === "tesSUCCESS") {
    console.log(`🎉 ${AMOUNT_TO_ISSUE} ${CURRENCY_CODE} の発行に成功しました！`);
  }

  await client.disconnect();
}

main().catch(console.error);
```

```bash
node issue-token.js
```

### 発行の仕組み

ここが面白いポイントです。XRPLでは、**発行者がトークンを送金する = 新しいトークンを発行する** ことになります。

- 発行者は無限にトークンを作り出せる（Trust Lineの上限まで）
- 発行者の残高は **マイナス** になる（これは「発行済み量」を意味する）
- 受取側の残高が **プラス** になる（保有量を意味する）

```
発行前：
  発行者の MIM 残高:  0
  受取側の MIM 残高:  0

発行後（10,000 MIM 発行）：
  発行者の MIM 残高: -10,000  ← 発行済み量
  受取側の MIM 残高: +10,000  ← 保有量
```

## Step 5：トークン残高の確認

発行したトークンの残高を確認してみましょう。

```javascript
// check-balance.js
const xrpl = require("xrpl");

const HOLDER_ADDRESS = "rYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY";
const ISSUER_ADDRESS = "rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";

async function main() {
  const client = new xrpl.Client("wss://s.altnet.rippletest.net:51233");
  await client.connect();

  // Trust Lineの残高を取得
  const response = await client.request({
    command: "account_lines",
    account: HOLDER_ADDRESS,
  });

  console.log("=== Trust Line 残高一覧 ===\n");

  if (response.result.lines.length === 0) {
    console.log("Trust Lineがありません");
  } else {
    for (const line of response.result.lines) {
      console.log(`通貨: ${line.currency}`);
      console.log(`発行者: ${line.account}`);
      console.log(`残高: ${line.balance}`);
      console.log(`上限: ${line.limit}`);
      console.log("---");
    }
  }

  // Gateway Balances（発行者視点の確認）
  console.log("\n=== 発行者から見た発行状況 ===\n");
  const gatewayResponse = await client.request({
    command: "gateway_balances",
    account: ISSUER_ADDRESS,
    hotwallet: [],
  });

  console.log("発行済み（obligations）:");
  console.log(JSON.stringify(gatewayResponse.result.obligations, null, 2));

  await client.disconnect();
}

main().catch(console.error);
```

```bash
node check-balance.js
```

出力例：

```
=== Trust Line 残高一覧 ===

通貨: MIM
発行者: rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
残高: 10000
上限: 1000000
---

=== 発行者から見た発行状況 ===

発行済み（obligations）:
{
  "MIM": "10000"
}
```

## Step 6：トークンの送金

発行されたトークンは、Trust Lineを設定している別のアカウントに送金できます。ここでは、3つ目のアカウントを作ってトークンを転送してみます。

```javascript
// transfer-token.js
const xrpl = require("xrpl");

const HOLDER_SEED = "sYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY";
const ISSUER_ADDRESS = "rXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
const CURRENCY_CODE = "MIM";

async function main() {
  const client = new xrpl.Client("wss://s.altnet.rippletest.net:51233");
  await client.connect();

  const holderWallet = xrpl.Wallet.fromSeed(HOLDER_SEED);

  // 3つ目のアカウントを作成
  console.log("送金先アカウントを作成中...");
  const receiverWallet = (await client.fundWallet()).wallet;
  console.log("送金先アドレス:", receiverWallet.classicAddress);

  // 送金先がTrust Lineを設定
  console.log("\n送金先のTrust Lineを設定中...");
  const trustSetTx = {
    TransactionType: "TrustSet",
    Account: receiverWallet.classicAddress,
    LimitAmount: {
      currency: CURRENCY_CODE,
      issuer: ISSUER_ADDRESS,
      value: "1000000",
    },
  };

  await client.submitAndWait(trustSetTx, { wallet: receiverWallet });
  console.log("Trust Line設定完了");

  // トークンを送金
  const transferAmount = "500";
  const paymentTx = {
    TransactionType: "Payment",
    Account: holderWallet.classicAddress,
    Destination: receiverWallet.classicAddress,
    Amount: {
      currency: CURRENCY_CODE,
      issuer: ISSUER_ADDRESS,
      value: transferAmount,
    },
  };

  console.log(`\n${transferAmount} ${CURRENCY_CODE} を送金中...`);
  const result = await client.submitAndWait(paymentTx, {
    wallet: holderWallet,
  });

  console.log("結果:", result.result.meta.TransactionResult);

  if (result.result.meta.TransactionResult === "tesSUCCESS") {
    console.log("送金成功！");

    // 残高確認
    const holderLines = await client.request({
      command: "account_lines",
      account: holderWallet.classicAddress,
    });
    const receiverLines = await client.request({
      command: "account_lines",
      account: receiverWallet.classicAddress,
    });

    const holderBalance = holderLines.result.lines.find(
      (l) => l.currency === CURRENCY_CODE
    );
    const receiverBalance = receiverLines.result.lines.find(
      (l) => l.currency === CURRENCY_CODE
    );

    console.log(`\n送金元の ${CURRENCY_CODE} 残高: ${holderBalance?.balance}`);
    console.log(`送金先の ${CURRENCY_CODE} 残高: ${receiverBalance?.balance}`);
  }

  await client.disconnect();
}

main().catch(console.error);
```

```bash
node transfer-token.js
```

## トークン設計のベストプラクティス

実際にプロジェクトでトークンを発行する際に気をつけるポイントをまとめます。

### 1. 発行者アカウントの管理

発行者アカウントは **特別な役割** を持つため、厳重に管理する必要があります。

- **マスターキーの無効化**：`AccountSet` で `asfDisableMaster` を設定し、レギュラーキーのみで運用する
- **マルチシグ**：複数の署名者による承認を必要にする
- **Black Hole化**：発行量を固定したい場合、発行者のキーを完全に無効化する

### 2. Transfer Fee（送金手数料）

発行者は、トークンの送金時に **手数料を徴収** する設定ができます。

```javascript
// 送金時に0.5%の手数料を設定する例
const transferRateTx = {
  TransactionType: "AccountSet",
  Account: issuerWallet.classicAddress,
  TransferRate: 1005000000, // 0.5% = 1,005,000,000
};
```

`TransferRate` は **10億（1,000,000,000）** を基準値とし、それに上乗せした値を指定します。

| TransferRate | 手数料 |
| --- | --- |
| 1,000,000,000 | 0%（デフォルト） |
| 1,005,000,000 | 0.5% |
| 1,010,000,000 | 1.0% |
| 1,100,000,000 | 10% |

### 3. Freeze（凍結）

発行者には、必要に応じてトークンを **凍結** する権限があります。

- **Individual Freeze**：特定のTrust Lineを凍結
- **Global Freeze**：発行した全トークンを凍結
- **No Freeze**：凍結権限を永久に放棄（信頼性の証明に使える）

### 4. リザーブ要件

XRPLではTrust Lineの設定に **オーナーリザーブ** が必要です。

- Trust Lineを1つ設定するごとに **2 XRP** がロックされる
- この分のXRPは送金に使えなくなる
- Trust Lineを削除すればリザーブは解放される

ユーザーにトークンを配布する際は、リザーブの負担も考慮に入れましょう。

## よくあるエラーと対処法

| エラーコード | 原因 | 対処法 |
| --- | --- | --- |
| `tecNO_LINE` | Trust Lineが設定されていない | 受取側にTrust Lineを設定してもらう |
| `tecPATH_DRY` | 送金経路が見つからない | 通貨コードや発行者アドレスが正しいか確認 |
| `tecUNFUNDED_PAYMENT` | 残高不足 | トークン残高またはXRP残高を確認 |
| `tecNO_LINE_INSUF_RESERVE` | リザーブ不足でTrust Lineを設定できない | XRPを追加で入金する |
| `tecFROZEN` | Trust Lineが凍結されている | 発行者に凍結解除を依頼する |

## XRPL Explorerで確認しよう

コードで確認するだけでなく、**XRPL Explorer** を使えばブラウザ上で視覚的にトランザクションやTrust Lineを確認できます。

テストネット用Explorer：
https://testnet.xrpl.org/

アカウントのアドレスを検索バーに入力すると、以下の情報が見られます。

- トランザクション履歴
- XRP残高
- Trust Line一覧とトークン残高
- アカウント設定（フラグ）

## まとめ

この記事では、XRPLでの独自トークン発行を実際にコードを動かしながら学びました。

### 手順のおさらい

1. **アカウント準備**：発行者と受取側の2つのアカウントを作成
2. **発行者設定**：DefaultRippleフラグを有効化
3. **Trust Line設定**：受取側がトークンの受取を許可
4. **トークン発行**：発行者から受取側へPaymentトランザクション
5. **残高確認**：`account_lines` や `gateway_balances` で確認
6. **トークン送金**：Trust Lineを持つ別アカウントへ転送

### XRPLトークンの特徴

- **手数料がほぼゼロ** で発行・送金ができる
- **Trust Lineの仕組み** でスパムトークンを防止
- **発行者に管理権限**（凍結・手数料設定など）がある
- **プロトコルレベル** で動作するため、スマートコントラクト不要

XRPLの公式ドキュメントには、さらに詳しい情報やサンプルコードが掲載されています。ぜひチェックしてみてください。

- [XRPL公式: Issue a Fungible Token](https://xrpl.org/docs/tutorials/how-tos/use-tokens/issue-a-fungible-token)
- [XRPL公式: Trust Lines and Issuing](https://xrpl.org/docs/concepts/tokens/)
- [xrpl.js ドキュメント](https://js.xrpl.org/)

最後まで読んでいただきありがとうございました！
